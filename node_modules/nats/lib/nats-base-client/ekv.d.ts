import { QueuedIterator } from "./queued_iterator";
import { PurgeOpts, PurgeResponse } from "./types";
import { Codec } from "./codec";
import { Bucket, Entry, KvStatus, PutOptions } from "./kv";
export interface EncodedEntry<T> {
    bucket: string;
    key: string;
    value?: T;
    created: Date;
    seq: number;
    delta?: number;
    "origin_cluster"?: string;
    operation: "PUT" | "DEL";
}
export interface EncodedRoKV<T> {
    get(k: string): Promise<EncodedEntry<T> | null>;
    history(k: string): Promise<QueuedIterator<EncodedEntry<T>>>;
    watch(opts?: {
        key?: string;
    }): Promise<QueuedIterator<EncodedEntry<T>>>;
    close(): Promise<void>;
    status(): Promise<KvStatus>;
    keys(): Promise<string[]>;
}
export interface EncodedKV<T> extends EncodedRoKV<T> {
    put(k: string, data?: T, opts?: Partial<PutOptions>): Promise<number>;
    delete(k: string): Promise<void>;
    purge(opts?: PurgeOpts): Promise<PurgeResponse>;
    destroy(): Promise<boolean>;
}
export declare class EncodedBucket<T> implements EncodedKV<T> {
    bucket: Bucket;
    codec: Codec<T>;
    constructor(bucket: Bucket, codec: Codec<T>);
    toEncodedEntry(e: Entry): EncodedEntry<T>;
    put(k: string, data: T, opts?: Partial<PutOptions>): Promise<number>;
    get(k: string): Promise<EncodedEntry<T> | null>;
    delete(k: string): Promise<void>;
    toEncodedIter(src: QueuedIterator<Entry>): Promise<QueuedIterator<EncodedEntry<T>>>;
    history(k: string): Promise<QueuedIterator<EncodedEntry<T>>>;
    watch(opts?: {
        key?: string;
    }): Promise<QueuedIterator<EncodedEntry<T>>>;
    keys(): Promise<string[]>;
    purge(opts?: PurgeOpts): Promise<PurgeResponse>;
    destroy(): Promise<boolean>;
    status(): Promise<KvStatus>;
    close(): Promise<void>;
}
