"use strict";
/*
 * Copyright 2021 The NATS Authors
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Bucket = exports.validateBucket = exports.validateKey = exports.kvOperationHdr = exports.kvOriginClusterHdr = exports.defaultBucketOpts = exports.NoopKvCodecs = exports.Base64KeyCodec = void 0;
const types_1 = require("./types");
const mod_1 = require("./mod");
const jsutil_1 = require("./jsutil");
const error_1 = require("./error");
const queued_iterator_1 = require("./queued_iterator");
const util_1 = require("./util");
const jsmsg_1 = require("./jsmsg");
function Base64KeyCodec() {
    return {
        encode(key) {
            return btoa(key);
        },
        decode(bkey) {
            return atob(bkey);
        },
    };
}
exports.Base64KeyCodec = Base64KeyCodec;
function NoopKvCodecs() {
    return {
        key: {
            encode(k) {
                return k;
            },
            decode(k) {
                return k;
            },
        },
        value: {
            encode(v) {
                return v;
            },
            decode(v) {
                return v;
            },
        },
    };
}
exports.NoopKvCodecs = NoopKvCodecs;
function defaultBucketOpts() {
    return {
        replicas: 1,
        history: 1,
        timeout: 2000,
        maxBucketSize: -1,
        maxValueSize: -1,
        codec: NoopKvCodecs(),
    };
}
exports.defaultBucketOpts = defaultBucketOpts;
exports.kvOriginClusterHdr = "KV-Origin-Cluster";
exports.kvOperationHdr = "KV-Operation";
const kvPrefix = "KV_";
const kvSubjectPrefix = "$KV";
const validKeyRe = /^[-/=.\w]+$/;
const validBucketRe = /^[-\w]+$/;
// this exported for tests
function validateKey(k) {
    if (k.startsWith(".") || k.endsWith(".") || !validKeyRe.test(k)) {
        throw new Error(`invalid key: ${k}`);
    }
}
exports.validateKey = validateKey;
// this exported for tests
function validateBucket(name) {
    if (!validBucketRe.test(name)) {
        throw new Error(`invalid bucket name: ${name}`);
    }
}
exports.validateBucket = validateBucket;
class Bucket {
    constructor(bucket, jsm, js) {
        this.validateKey = validateKey;
        validateBucket(bucket);
        this.jsm = jsm;
        this.js = js;
        this.bucket = bucket;
    }
    static create(nc, name, opts = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            validateBucket(name);
            const to = opts.timeout || 2000;
            const jsm = yield nc.jetstreamManager({ timeout: to });
            const bucket = new Bucket(name, jsm, nc.jetstream({ timeout: to }));
            yield bucket.init(opts);
            return bucket;
        });
    }
    init(opts = {}) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const bo = Object.assign(defaultBucketOpts(), opts);
            this.codec = bo.codec;
            const sc = {};
            this.stream = sc.name = (_a = opts.streamName) !== null && _a !== void 0 ? _a : this.bucketName();
            sc.subjects = [this.subjectForBucket()];
            sc.retention = types_1.RetentionPolicy.Limits;
            sc.max_msgs_per_subject = bo.history;
            sc.max_bytes = bo.maxBucketSize;
            sc.max_msg_size = bo.maxValueSize;
            sc.storage = types_1.StorageType.File;
            sc.discard = types_1.DiscardPolicy.Old;
            sc.num_replicas = bo.replicas;
            if (bo.ttl) {
                sc.max_age = mod_1.nanos(bo.ttl);
            }
            try {
                yield this.jsm.streams.info(sc.name);
            }
            catch (err) {
                if (err.message === "stream not found") {
                    yield this.jsm.streams.add(sc);
                }
            }
        });
    }
    bucketName() {
        var _a;
        return (_a = this.stream) !== null && _a !== void 0 ? _a : `${kvPrefix}${this.bucket}`;
    }
    subjectForBucket() {
        return `${kvSubjectPrefix}.${this.bucket}.*`;
    }
    subjectForKey(k) {
        return `${kvSubjectPrefix}.${this.bucket}.${k}`;
    }
    encodeKey(key) {
        const chunks = [];
        for (const t of key.split(".")) {
            switch (t) {
                case ">":
                case "*":
                    chunks.push(t);
                    break;
                default:
                    chunks.push(this.codec.key.encode(t));
                    break;
            }
        }
        return chunks.join(".");
    }
    close() {
        return Promise.resolve();
    }
    smToEntry(key, sm) {
        return {
            bucket: this.bucket,
            key: key,
            value: sm.data,
            delta: 0,
            created: sm.time,
            seq: sm.seq,
            origin_cluster: sm.header.get(exports.kvOriginClusterHdr),
            operation: sm.header.get(exports.kvOperationHdr) === "DEL" ? "DEL" : "PUT",
        };
    }
    jmToEntry(k, jm) {
        var _a, _b;
        const chunks = jm.subject.split(".");
        const key = this.codec.key.decode(chunks[chunks.length - 1]);
        const e = {
            bucket: this.bucket,
            key: key,
            value: jm.data,
            created: new Date(mod_1.millis(jm.info.timestampNanos)),
            seq: jm.seq,
            origin_cluster: (_a = jm.headers) === null || _a === void 0 ? void 0 : _a.get(exports.kvOriginClusterHdr),
            operation: ((_b = jm.headers) === null || _b === void 0 ? void 0 : _b.get(exports.kvOperationHdr)) === "DEL" ? "DEL" : "PUT",
        };
        if (k !== "*") {
            e.delta = jm.info.pending;
        }
        return e;
    }
    put(k, data, opts = {}) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const ek = this.encodeKey(k);
            this.validateKey(ek);
            const ji = this.js;
            const cluster = (_b = (_a = ji.nc.info) === null || _a === void 0 ? void 0 : _a.cluster) !== null && _b !== void 0 ? _b : "";
            const h = mod_1.headers();
            h.set(exports.kvOriginClusterHdr, cluster);
            const o = { headers: h };
            if (opts.previousSeq) {
                o.expect = {};
                o.expect.lastSubjectSequence = opts.previousSeq;
            }
            const pa = yield this.js.publish(this.subjectForKey(ek), data, o);
            return pa.seq;
        });
    }
    get(k) {
        return __awaiter(this, void 0, void 0, function* () {
            const ek = this.encodeKey(k);
            this.validateKey(ek);
            try {
                const sm = yield this.jsm.streams.getMessage(this.bucketName(), {
                    last_by_subj: this.subjectForKey(ek),
                });
                return this.smToEntry(k, sm);
            }
            catch (err) {
                if (err.message === "no message found") {
                    return null;
                }
                throw err;
            }
        });
    }
    delete(k) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const ek = this.encodeKey(k);
            this.validateKey(ek);
            const ji = this.js;
            const cluster = (_b = (_a = ji.nc.info) === null || _a === void 0 ? void 0 : _a.cluster) !== null && _b !== void 0 ? _b : "";
            const h = mod_1.headers();
            h.set(exports.kvOriginClusterHdr, cluster);
            h.set(exports.kvOperationHdr, "DEL");
            yield this.js.publish(this.subjectForKey(ek), types_1.Empty, { headers: h });
        });
    }
    consumerOn(k, lastOnly = false) {
        const ek = this.encodeKey(k);
        if (k !== "*") {
            this.validateKey(ek);
        }
        const ji = this.js;
        const nc = ji.nc;
        const inbox = mod_1.createInbox(nc.options.inboxPrefix);
        const opts = {
            "deliver_subject": inbox,
            "deliver_policy": lastOnly
                ? types_1.DeliverPolicy.LastPerSubject
                : types_1.DeliverPolicy.All,
            "ack_policy": types_1.AckPolicy.Explicit,
            "filter_subject": this.subjectForKey(ek),
            "flow_control": k === "*",
        };
        return this.jsm.consumers.add(this.stream, opts);
    }
    history(k) {
        return __awaiter(this, void 0, void 0, function* () {
            const ci = yield this.consumerOn(k);
            const max = ci.num_pending;
            const qi = new queued_iterator_1.QueuedIteratorImpl();
            if (max === 0) {
                qi.stop();
                return qi;
            }
            const ji = this.jsm;
            const nc = ji.nc;
            const subj = ci.config.deliver_subject;
            const sub = nc.subscribe(subj, {
                callback: (err, msg) => {
                    if (err === null) {
                        err = jsutil_1.checkJsError(msg);
                    }
                    if (err) {
                        if (error_1.isNatsError(err)) {
                            qi.stop(err);
                        }
                    }
                    else {
                        if (mod_1.isFlowControlMsg(msg) || mod_1.isHeartbeatMsg(msg)) {
                            msg.respond();
                            return;
                        }
                        qi.received++;
                        const jm = mod_1.toJsMsg(msg);
                        qi.push(this.jmToEntry(k, jm));
                        jm.ack();
                        if (qi.received === max) {
                            sub.unsubscribe();
                        }
                    }
                },
            });
            sub.closed.then(() => {
                qi.stop();
            }).catch((err) => {
                qi.stop(err);
            });
            return qi;
        });
    }
    watch(opts = {}) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const k = (_a = opts.key) !== null && _a !== void 0 ? _a : "*";
            const ci = yield this.consumerOn(k, k !== "*");
            const qi = new queued_iterator_1.QueuedIteratorImpl();
            const ji = this.jsm;
            const nc = ji.nc;
            const subj = ci.config.deliver_subject;
            const sub = nc.subscribe(subj, {
                callback: (err, msg) => {
                    if (err === null) {
                        err = jsutil_1.checkJsError(msg);
                    }
                    if (err) {
                        if (error_1.isNatsError(err)) {
                            qi.stop(err);
                        }
                    }
                    else {
                        if (mod_1.isFlowControlMsg(msg) || mod_1.isHeartbeatMsg(msg)) {
                            msg.respond();
                            return;
                        }
                        qi.received++;
                        const jm = mod_1.toJsMsg(msg);
                        qi.push(this.jmToEntry(k, jm));
                        jm.ack();
                    }
                },
            });
            sub.closed.then(() => {
                qi.stop();
            }).catch((err) => {
                qi.stop(err);
            });
            return qi;
        });
    }
    keys() {
        return __awaiter(this, void 0, void 0, function* () {
            const d = util_1.deferred();
            const s = [];
            const ci = yield this.consumerOn("*", true);
            const ji = this.jsm;
            const nc = ji.nc;
            const subj = ci.config.deliver_subject;
            const sub = nc.subscribe(subj);
            yield (() => __awaiter(this, void 0, void 0, function* () {
                var e_1, _a;
                try {
                    for (var sub_1 = __asyncValues(sub), sub_1_1; sub_1_1 = yield sub_1.next(), !sub_1_1.done;) {
                        const m = sub_1_1.value;
                        const err = jsutil_1.checkJsError(m);
                        if (err) {
                            sub.unsubscribe();
                            d.reject(err);
                        }
                        else if (mod_1.isFlowControlMsg(m)) {
                            m.respond();
                        }
                        else {
                            const chunks = m.subject.split(".");
                            s.push(this.codec.key.decode(chunks[chunks.length - 1]));
                            m.respond();
                            const info = jsmsg_1.parseInfo(m.reply);
                            if (info.pending === 0) {
                                sub.unsubscribe();
                                d.resolve(s);
                            }
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (sub_1_1 && !sub_1_1.done && (_a = sub_1.return)) yield _a.call(sub_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }))();
            return d;
        });
    }
    purge(opts) {
        return this.jsm.streams.purge(this.bucketName(), opts);
    }
    destroy() {
        return this.jsm.streams.delete(this.bucketName());
    }
    status() {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const ji = this.js;
            const cluster = (_b = (_a = ji.nc.info) === null || _a === void 0 ? void 0 : _a.cluster) !== null && _b !== void 0 ? _b : "";
            const si = yield this.jsm.streams.info(this.bucketName());
            return {
                bucket: this.bucketName(),
                values: si.state.messages,
                history: si.config.max_msgs_per_subject,
                ttl: si.config.max_age,
                bucket_location: cluster,
                backingStore: si.config.storage,
            };
        });
    }
}
exports.Bucket = Bucket;
//# sourceMappingURL=kv.js.map