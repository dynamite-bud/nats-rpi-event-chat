import { ConsumerInfo, JetStreamClient, JetStreamManager, JsMsg, Nanos, NatsConnection, PurgeOpts, PurgeResponse, StorageType, StoredMsg } from "./types";
import { QueuedIterator } from "./queued_iterator";
export interface Entry {
    bucket: string;
    key: string;
    value: Uint8Array;
    created: Date;
    seq: number;
    delta?: number;
    "origin_cluster"?: string;
    operation: "PUT" | "DEL";
}
export interface KvCodec<T> {
    encode(k: T): T;
    decode(k: T): T;
}
export interface KvCodecs {
    key: KvCodec<string>;
    value: KvCodec<Uint8Array>;
}
export declare function Base64KeyCodec(): KvCodec<string>;
export declare function NoopKvCodecs(): KvCodecs;
export interface KvStatus {
    bucket: string;
    values: number;
    history: number;
    ttl: Nanos;
    cluster?: string;
    backingStore: StorageType;
}
export interface BucketOpts {
    replicas: number;
    history: number;
    timeout: number;
    maxBucketSize: number;
    maxValueSize: number;
    placementCluster: string;
    mirrorBucket: string;
    ttl: number;
    streamName: string;
    codec: KvCodecs;
}
export declare function defaultBucketOpts(): Partial<BucketOpts>;
export interface PutOptions {
    previousSeq: number;
}
export declare const kvOriginClusterHdr = "KV-Origin-Cluster";
export declare const kvOperationHdr = "KV-Operation";
export interface RoKV {
    get(k: string): Promise<Entry | null>;
    history(k: string): Promise<QueuedIterator<Entry>>;
    watch(opts?: {
        key?: string;
    }): Promise<QueuedIterator<Entry>>;
    close(): Promise<void>;
    status(): Promise<KvStatus>;
    keys(): Promise<string[]>;
}
export interface KV extends RoKV {
    put(k: string, data: Uint8Array, opts?: Partial<PutOptions>): Promise<number>;
    delete(k: string): Promise<void>;
    purge(opts?: PurgeOpts): Promise<PurgeResponse>;
    destroy(): Promise<boolean>;
}
export declare function validateKey(k: string): void;
export declare function validateBucket(name: string): void;
export declare class Bucket implements KV {
    jsm: JetStreamManager;
    js: JetStreamClient;
    stream: string;
    bucket: string;
    codec: KvCodecs;
    constructor(bucket: string, jsm: JetStreamManager, js: JetStreamClient);
    static create(nc: NatsConnection, name: string, opts?: Partial<BucketOpts>): Promise<KV>;
    init(opts?: Partial<BucketOpts>): Promise<void>;
    bucketName(): string;
    subjectForBucket(): string;
    subjectForKey(k: string): string;
    encodeKey(key: string): string;
    validateKey: typeof validateKey;
    close(): Promise<void>;
    smToEntry(key: string, sm: StoredMsg): Entry;
    jmToEntry(k: string, jm: JsMsg): Entry;
    put(k: string, data: Uint8Array, opts?: Partial<PutOptions>): Promise<number>;
    get(k: string): Promise<Entry | null>;
    delete(k: string): Promise<void>;
    consumerOn(k: string, lastOnly?: boolean): Promise<ConsumerInfo>;
    history(k: string): Promise<QueuedIterator<Entry>>;
    watch(opts?: {
        key?: string;
    }): Promise<QueuedIterator<Entry>>;
    keys(): Promise<string[]>;
    purge(opts?: PurgeOpts): Promise<PurgeResponse>;
    destroy(): Promise<boolean>;
    status(): Promise<KvStatus>;
}
